## 程序员的数学

    此工程的代码，基于平冈和幸的《程序员的数学》系列一书的例子进行编码(原书的代码是由R语言编写的)。
    意图通过go语言把书籍中通俗易懂的数学思想表达出来。

### monty

    蒙提霍尔问题。三门问题：参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门就可以赢得该汽车，
    而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人会开启剩下两扇门的其中一扇，
    露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机会率？
    如果严格按照上述的条件的话，答案是会—换门的话，赢得汽车的机会率是 2/3。
    本例中采用是多协程模拟指定场数的形式，并将改变与不改变的结果，存入到最终数组，通过plot的方式，绘制到图上。
    其实三门问题，是多门问题的简化版本，意图是，当你不知道正确结果的时候，随机选择了一个结果，但是有外部力量
    把一个错误结果展示给你的时候，你应该作出改变还是不改变，这里不涉及任何有助于猜想其他情况的信息。正解是作出改变
    参见 https://zhuanlan.zhihu.com/p/464351914
    假设有门A、B、C
    门A后有将的概率事件a，概率为P(a)=1/3;
    门B后有将的概率事件b，概率为P(b)=1/3;
    门B后有将的概率事件c，概率为P(c)=1/3;
    到此是一个概率和为1的。
    参赛者随机选择一个门，假设为A门，是一个必然事件h
    主持人打开一个门，假设是B门，这是概率事件d P(d)
    求解的就是“空门打开后，不更改选择的胜率”P(a|d)，以及“更改选择的胜率”P(c|d)
    根据贝叶斯公式，P(a|d)=P(d|a)*P(a)/P(d),
    根据全概率公式，P(d)= P(d|a)*P(a)+ P(d|b)*P(b)+ P(d|c)*P(c)。
    P(c|d)=P(d|c)*P(c)/P(d)    

    条件概率P(d|a) 的物理意义是“当a事件，即A门后有大奖的事件发生时，主持人打开B门的概率“。 
    显然，这时主持人可以打开B门，也可以开C门，所以这个概率就是P(d|a)=1/2
    
    条件概率P(d|b) 的物理意义是“当b事件，即B门后有大奖的事件发生时，主持人打开B门的概率“。 
    这时主持人不能打开B门，所以这个概率就是P(d|b)=0。
    
    条件概率P(d|c) 的物理意义是“当c事件，即C门后有大奖的事件发生时，主持人打开B门的概率“。 
    这时主持人只能打开B门，所以这个概率就是P(d|c)=1。

    把上面已知数据代入，就得到“不更改的胜率“P(a|d)=1/2*1/3/(1/2*1/3+0*1/3+1*1/3)=1/3；
    而”更改后的胜率“P(c|d)=1*1/3/(1/2*1/3+0*1/3+1*1/3)=2/3。

    通过数学公式得到的结果会更有信服力。

### accident

    常言道：屋漏偏逢连阴雨，这是否表示事故一旦发生，之后继续发生事故的概率会变大呢

### portfolio

    投资组合问题
    设结果“甲”的出现概率是0.7，结果“乙”的出现概率是0.3。且无论选择甲还是乙，只要猜中，就能获得双倍下注金额。
    显然，选择甲是明智的选择。
    假设你每天都会投入所有资产参与这场赌博。具体来说，你将会占总资产比例p的金额投给甲，再将剩余的投给乙。
    这里的p是一个事先确定的值。该值在整个过程中将保持不变，请问应该如何设定p的值？
    如果只考虑一天的收益，显然p=1(即把所有的资产都投给甲)是最佳选项，然而，在不断重复这场赌局时，总会出现没有中奖而
    失去所有财产的情况。

    选择p=0.7
        column   val
    0: mean     1.535600
    1: median   1.400000
    2: stddev   0.435956
    3: min      1.000000
    4: 25%      1.400000
    5: 50%      1.400000
    6: 75%      1.600000
    7: max      2.240000
    <string> <float>
    选择p=0.99
        column   val
    0: mean     1.746892
    1: median   1.980000
    2: stddev   0.430945
    3: min      1.000000
    4: 25%      1.020000
    5: 50%      1.980000
    6: 75%      2.019600
    7: max      2.019600
    <string> <float>
    从统计的中位数上看：我们不应该将所有资产集中投资于胜率最高的一方，而应当分散资金，也适当投资其他胜率较低的选项

### cake

    我们要将蛋糕分给ABCDE五个人，切4刀，完全随机，以此分给ABCDE，重复实验10000次，看各自的统计分布
    从统计的结果来看中位数和平均值，先切的那个有大的值，这叫先手优势

### nearest

    考虑边长为1的d维立方体，且该立方体中包含了100个基于均匀分布得到的独立的点。此时，第1个点与其他点之间的最短距离是多少
    实验 d=2 循环50次的结果
    column   distance_min
    0: mean     0.050036
    1: median   0.048066
    2: stddev   0.026124
    3: min      0.003686
    4: 25%      0.030206
    5: 50%      0.046120
    6: 75%      0.065252
    7: max      0.124813

    实验 d=20 循环50次的结果
      column   distance_min
    0: mean     0.996066
    1: median   1.000000
    2: stddev   0.020280
    3: min      0.873507
    4: 25%      1.000000
    5: 50%      1.000000
    6: 75%      1.000000

    根据结果，我们发现随着维数的增加，各点之间的距离也会相应的增加。这算是一种维数的诅咒。
    在进行高维数据分析、预测或模式识别等处理时，这种现象会给我们带来不小的麻烦
    
### tomoe

    tomoe巴战，一种日本相扑力对决的规矩。巴战需要A、B、C三名参赛选手，并按以下方式决出优胜者。
    败者下场的车轮战，
    谁选获得连胜即为最终优胜者。
    在确定A、B、C的胜率后，通过计算机模拟1000次巴战情况，并记录每个人的优胜次数。

        A   B   C 胜率
    ====0.5 0.5 0.5
    A:348 0.348
    B:364 0.364
    C:288 0.288

    ====0.5 0.45 0.55
    A:350 0.35
    B:325 0.325
    C:325 0.325
    
    ====0.5 0.4 0.6
    A:315 0.315
    B:303 0.303
    C:382 0.382

    ====0.5 0.35 0.65
    A:266 0.266
    B:271 0.271
    C:463 0.463

    ====0.5 0.3 0.7
    A:225 0.225
    B:199 0.199
    C:576 0.576

    不难看出，巴战的对决顺序会影响比赛的公平性，最后的C，即使实力很强，但胜率提升的速度却不快

### sugoroku

    sugoroku日本双陆，日本双陆棋盘上仅有一条路线，且长度无限。路线上随机设有一些陷阱，
    如果玩家落入陷阱，则判庄家胜利。如果玩家躲过了所有的陷阱，庄家就输了游戏。
    陷阱数 实验次数
    t 1 c 10000
    win:7150 0.715
    lose:2850 0.285

    t 5 c 10000
    win:1817 0.1817
    lose:8183 0.8183

    t 10 c 10000
    win:349 0.0349
    lose:9651 0.9651

    陷阱越多，胜率越低

### pattern

    假设有一条由0和1随机生成的字符串(两者的出现概率都是给0.5，且每个字符互相独立)，
    我们的目标是计算给定模式下首次出现的字符串长度。

    对于不同的模式，这样定义的长度的期望值是否发生改变

    模式 01 次数 20

    column   次数
    0: mean     4.700000
    1: median   4.000000
    2: stddev   2.473012
    3: min      2.000000
    4: 25%      3.000000
    5: 50%      4.000000
    6: 75%      6.000000
    7: max      12.000000

    模式 10 次数 20
        column   次数
    0: mean     3.800000
    1: median   3.000000
    2: stddev   1.823819
    3: min      2.000000
    4: 25%      2.000000
    5: 50%      3.000000
    6: 75%      5.000000
    7: max      8.000000

    模式 11 次数 20
        column   次数
    0: mean     6.000000
    1: median   3.500000
    2: stddev   5.803810
    3: min      2.000000
    4: 25%      2.000000
    5: 50%      3.000000
    6: 75%      7.000000
    7: max      21.000000


    模式 10 次数 10000
        column   次数
    0: mean     4.020100
    1: median   4.000000
    2: stddev   2.009502
    3: min      2.000000
    4: 25%      3.000000
    5: 50%      4.000000
    6: 75%      5.000000
    7: max      17.000000

    模式 11 次数 10000
        column   次数
    0: mean     5.946200
    1: median   4.000000
    2: stddev   4.614763
    3: min      2.000000
    4: 25%      2.000000
    5: 50%      4.000000
    6: 75%      8.000000
    7: max      46.000000

    可以看到模式11出现的字符串通常比较长